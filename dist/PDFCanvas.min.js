var PDFCanvas = function() {
  if(!("jsPDF" in window)) {
    throw"jsPDF is missing, make sure to include it before using PDFCanvas.";
  }
  var c = function(a) {
    var b = a.toLowerCase(), b = b.replace(/[\s]+/ig, ""), c = cR = cG = cB = void 0;
    if(-1 !== b.indexOf("#")) {
      a = b.replace("#", "0x"), 5 == a.length && (a = "0x" + a[2] + a[2] + a[3] + a[3] + a[4] + a[4]), a = parseInt(a, 16), 16777215 < a && (c = (a >> 24 & 255) / 255), cR = a >> 16 & 255, cG = a >> 8 & 255, cB = a & 255
    }else {
      if(-1 !== b.indexOf("rgb")) {
        b = b.replace(/rgb[a]?\(([^)]+)\)/ig, "$1"), cArr = b.split(","), cR = parseInt(cArr[0]), cG = parseInt(cArr[1]), cB = parseInt(cArr[2]), (c = cArr[3] ? parseFloat(cArr[3]) : void 0) && 1 < c && (c /= 255)
      }else {
        if(-1 !== b.indexOf("hsl")) {
          throw"HSL colors are not yet implemented";
        }
        if(h && b in h) {
          return h[b]
        }
        throw"Unable to parse color style: " + a;
      }
    }
    cR /= 255;
    cG /= 255;
    cB /= 255;
    return{r:cR, g:cG, b:cB, a:c}
  }, k = function(a, b) {
    var c = parseInt(255 * a.r) + "," + parseInt(255 * a.g) + "," + parseInt(255 * a.b);
    return 1 !== b ? "rgba(" + c + "," + b + ")" : "rgb(" + c + ")"
  }, h = {aqua:c("#00FFFF"), black:c("#000000"), blue:c("#0000FF"), fuchsia:c("#FF00FF"), gray:c("#808080"), green:c("#008000"), lime:c("#00FF00"), maroon:c("#800000"), navy:c("#000080"), olive:c("#808000"), purple:c("#800080"), red:c("#FF0000"), silver:c("#C0C0C0"), teal:c("#008080"), white:c("#FFFFFF"), yellow:c("#FFFF00"), transparent:c("#ffffffff")}, i = function() {
    this.reset()
  };
  i.prototype = {reset:function() {
    this.fill = this.stroke = {r:0, g:0, b:0};
    this.globalAlpha = 1;
    this.globalCompositeOperation = "source-over";
    this.lineCap = "butt";
    this.lineJoine = "miter";
    this.lineWidth = 1;
    this.miterLimit = null;
    this.shadowBlur = this.shadowOffsetX = this.shadowOffsetY = 0;
    this.fontFamily = this.shadowColor = null;
    this.fontSize = 10;
    this.fontStretch = this.fontVariant = this.fontStyle = this.fontWeight = null;
    this.textAlign = "start";
    this.textBaseline = "alphabetic"
  }};
  var f = function() {
    this.stack = [new i]
  };
  f.prototype = {push:function() {
    var a = new i;
    this.stack.push(a);
    return a
  }, pop:function() {
    if(0 == this.stack.length) {
      throw"Number of save() / restore() do not match!";
    }
    return this.stack.pop()
  }, top:function() {
    return this.stack[this.stack.length - 1]
  }};
  var l = function() {
    this.vertices = []
  };
  l.prototype = {moveTo:function(a, b) {
    this.vertices.push([a, b])
  }, lineTo:function(a, b) {
    this.vertices.push([a, b])
  }};
  var p = void 0, e = new f, d = e.top(), g = null, m = function() {
  };
  m.prototype = {get canvas() {
    return n
  }, save:function() {
    e.push();
    d = e.top()
  }, restore:function() {
    e.pop();
    d = e.top()
  }, scale:function() {
  }, rotate:function() {
  }, translate:function() {
  }, transform:function() {
  }, setTransform:function() {
  }, get globalAlpha() {
    return d.globalAlpha
  }, set globalAlpha(a) {
    d.globalAlpha = a
  }, get globalCompositeOperation() {
    return d.globalCompositeOperation
  }, set globalCompositeOperation(a) {
    d.globalCompositeOperation = a;
    throw"Not yet implemented.";
  }, get strokeStyle() {
    return k(d.stroke, d.globalAlpha)
  }, set strokeStyle(a) {
    a = c(a);
    d.stroke = a
  }, get fillStyle() {
    return k(d.fill, d.globalAlpha)
  }, set fillStyle(a) {
    a = c(a);
    d.fill = a
  }, createLinearGradient:function() {
    throw"Not yet implemented.";
  }, createRadialGradient:function() {
    throw"Not yet implemented.";
  }, createPattern:function() {
    throw"Not yet implemented.";
  }, get lineWidth() {
    return d.lineWidth
  }, set lineWidth(a) {
    d.lineWidth = a
  }, get lineCap() {
    return d.lineCap
  }, set lineCap(a) {
    -1 !== ["butt", "round", "square"].indexOf(a.toLowerCase()) && (d.lineCap = a)
  }, get lineJoin() {
    return d.lineJoin
  }, set lineJoin(a) {
    -1 !== ["round", "bevel", "miter"].indexOf(a.toLowerCase()) && (d.lineJoin = a)
  }, get miterLimit() {
    return d.miterLimit
  }, set miterLimit(a) {
    d.miterLimit = a
  }, get font() {
  }, set font(a) {
  }, get textAlign() {
  }, set textAlign(a) {
  }, get textBaseline() {
  }, set textBaseline(a) {
  }, get shadowOffsetX() {
  }, set shadowOffsetX(a) {
  }, get shadowOffsetY() {
  }, set shadowOffsetY(a) {
  }, get shadowBlur() {
  }, set shadowBlur(a) {
  }, get shadowColor() {
  }, set shadowColor(a) {
  }, clearRect:function() {
    throw"Pixel operation, makes no sense for PDF vectors.";
  }, fillRect:function() {
  }, strokeRect:function() {
  }, beginPath:function() {
    g = new l
  }, fill:function() {
  }, stroke:function() {
  }, clip:function() {
    throw"Not implemented yet";
  }, isPointInPath:function() {
    throw"Not implemented yet";
  }, closePath:function() {
    g.closePath()
  }, moveTo:function(a, b) {
    g.moveTo(a, b)
  }, lineTo:function(a, b) {
    g.lineTo(a, b)
  }, quadraticCurveTo:function() {
  }, bezierCurveTo:function(a, b, c, d, f, e) {
    g.bezierCurveTo(a, b, c, d, f, e)
  }, arcTo:function() {
  }, rect:function() {
  }, arc:function() {
  }, fillText:function() {
    throw"Not implemented yet";
  }, strokeText:function() {
    throw"Not implemented yet";
  }, measureText:function() {
    throw"Not implemented yet";
  }, drawImage:function() {
    throw"Not implemented yet";
  }, addHitRegion:function() {
    throw"Interactive features make no sense in a stitic PDF context";
  }, removeHitRegion:function() {
    throw"Interactive features make no sense in a stitic PDF context";
  }, createImageData:function() {
    throw"Pixel operations make no sense in a PDF vector context";
  }, getImageData:function() {
    throw"Pixel operations make no sense in a PDF vector context";
  }, putImageData:function() {
    throw"Pixel operations make no sense in a PDF vector context";
  }};
  var j = null, n, f = function() {
    if(1 == arguments.length) {
      if("string" === typeof arguments[0] ? j = document.getElementById(arguments[0]) : "object" === typeof arguments[0] && (j = arguments[0]), !j) {
        throw"Unable to find target dom element from " + arguments[0];
      }
    }else {
      2 == arguments.length && (parseInt(arguments[0]), parseInt(arguments[1]))
    }
    n = this;
    new jsPDF
  };
  f.prototype = {getContext:function(a) {
    if("2d" === a.toString().toLowerCase()) {
      return p = new m
    }
    throw"PDFCanvas only supports the 2D context";
  }, toDataURL:function(a) {
    if("application/pdf" !== a) {
      throw'Can only output generated PDF to data-url of type "application/pdf".';
    }
  }, toBlob:function() {
    throw"Not (yet) implemented.";
  }, get width() {
    return pdfWidth
  }, set width(a) {
    pdfWidth = parseInt(a)
  }, get height() {
    return pdfHeight
  }, set height(a) {
    pdfHeight = parseInt(a)
  }, test:function() {
    a: {
      console.log("Testing color style to color conversion ...");
      for(var a = [["#ff00ff", {r:1, g:0, b:1}], ["#f0f", {r:1, g:0, b:1}], ["#eeff00ff", {r:1, g:0, b:1, a:238 / 255}], ["rgb(255,255,0)", {r:1, g:1, b:0}], ["rgba(255,0,0,255)", {r:1, g:0, b:0, a:1}], ["rgba(255,0,0,0.5)", {r:1, g:0, b:0, a:0.5}], ["red", {r:1, g:0, b:0}]], b = 0, d = a.length;b < d;b++) {
        var f = c(a[b][0]), e;
        for(e in a[b][1]) {
          if(a[b][1][e] !== f[e]) {
            console.log("Failed!", a[b][0], a[b][1], f);
            break a
          }
        }
      }
      console.log("... all fine!")
    }
  }};
  return f
}();
