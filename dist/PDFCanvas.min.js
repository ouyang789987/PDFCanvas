var PDFCanvas = function() {
  if(!("jsPDF" in window)) {
    throw"jsPDF is missing, make sure to include it before using PDFCanvas.";
  }
  var c = function(a) {
    var d = a.toLowerCase(), d = d.replace(/[\s]+/ig, ""), b = cR = cG = cB = void 0;
    if(-1 !== d.indexOf("#")) {
      a = d.replace("#", "0x"), 5 == a.length && (a = "0x" + a[2] + a[2] + a[3] + a[3] + a[4] + a[4]), a = parseInt(a, 16), 16777215 < a && (b = (a >> 24 & 255) / 255), cR = a >> 16 & 255, cG = a >> 8 & 255, cB = a & 255
    }else {
      if(-1 !== d.indexOf("rgb")) {
        d = d.replace(/rgb[a]?\(([^)]+)\)/ig, "$1"), cArr = d.split(","), cR = parseInt(cArr[0]), cG = parseInt(cArr[1]), cB = parseInt(cArr[2]), (b = cArr[3] ? parseFloat(cArr[3]) : void 0) && 1 < b && (b /= 255)
      }else {
        if(-1 !== d.indexOf("hsl")) {
          throw"HSL colors are not yet implemented";
        }
        if(m && d in m) {
          return m[d]
        }
        throw"Unable to parse color style: " + a;
      }
    }
    cR /= 255;
    cG /= 255;
    cB /= 255;
    return{r:cR, g:cG, b:cB, a:b}
  }, p = function(a, d) {
    var b = parseInt(255 * a.r) + "," + parseInt(255 * a.g) + "," + parseInt(255 * a.b);
    return 1 !== d ? "rgba(" + b + "," + d + ")" : "rgb(" + b + ")"
  }, m = {aqua:c("#00FFFF"), black:c("#000000"), blue:c("#0000FF"), fuchsia:c("#FF00FF"), gray:c("#808080"), green:c("#008000"), lime:c("#00FF00"), maroon:c("#800000"), navy:c("#000080"), olive:c("#808000"), purple:c("#800080"), red:c("#FF0000"), silver:c("#C0C0C0"), teal:c("#008080"), white:c("#FFFFFF"), yellow:c("#FFFF00"), transparent:c("#ffffffff")}, q = function() {
    e.setFillColor(255 * b.fill.r, 255 * b.fill.g, 255 * b.fill.b);
    e.setDrawColor(255 * b.stroke.r, 255 * b.stroke.g, 255 * b.stroke.b);
    e.setLineWidth(b.lineWidth)
  }, n = function() {
    this.reset()
  };
  n.prototype = {reset:function() {
    this.fill = this.stroke = {r:0, g:0, b:0};
    this.globalAlpha = 1;
    this.globalCompositeOperation = "source-over";
    this.lineCap = "butt";
    this.lineJoine = "miter";
    this.lineWidth = 1;
    this.miterLimit = null;
    this.shadowBlur = this.shadowOffsetX = this.shadowOffsetY = 0;
    this.fontFamily = this.shadowColor = null;
    this.fontSize = 10;
    this.fontStretch = this.fontVariant = this.fontStyle = this.fontWeight = null;
    this.textAlign = "start";
    this.textBaseline = "alphabetic"
  }};
  var f = function() {
    this.stack = [new n]
  };
  f.prototype = {push:function() {
    var a = new n;
    this.stack.push(a);
    return a
  }, pop:function() {
    if(0 == this.stack.length) {
      throw"Number of save() / restore() do not match!";
    }
    return this.stack.pop()
  }, top:function() {
    return this.stack[this.stack.length - 1]
  }};
  var r = function() {
    this.vertices = []
  };
  r.prototype = {moveTo:function(a, b) {
    this.vertices.push([a, b])
  }, lineTo:function(a, b) {
    this.vertices.push([a, b])
  }, quadraticCurveTo:function() {
  }, bezierCurveTo:function() {
  }, closePath:function() {
  }};
  var u = void 0, h = new f, b = h.top(), i = null, s = function() {
  };
  s.prototype = {get canvas() {
    return t
  }, save:function() {
    h.push();
    b = h.top()
  }, restore:function() {
    h.pop();
    b = h.top()
  }, scale:function() {
  }, rotate:function() {
  }, translate:function() {
  }, transform:function() {
  }, setTransform:function() {
  }, get globalAlpha() {
    return b.globalAlpha
  }, set globalAlpha(a) {
    b.globalAlpha = a
  }, get globalCompositeOperation() {
    return b.globalCompositeOperation
  }, set globalCompositeOperation(a) {
    b.globalCompositeOperation = a;
    throw"Not yet implemented.";
  }, get strokeStyle() {
    return p(b.stroke, b.globalAlpha)
  }, set strokeStyle(a) {
    a = c(a);
    b.stroke = a
  }, get fillStyle() {
    return p(b.fill, b.globalAlpha)
  }, set fillStyle(a) {
    a = c(a);
    b.fill = a
  }, createLinearGradient:function() {
    throw"Not yet implemented.";
  }, createRadialGradient:function() {
    throw"Not yet implemented.";
  }, createPattern:function() {
    throw"Not yet implemented.";
  }, get lineWidth() {
    return b.lineWidth
  }, set lineWidth(a) {
    b.lineWidth = a
  }, get lineCap() {
    return b.lineCap
  }, set lineCap(a) {
    -1 !== ["butt", "round", "square"].indexOf(a.toLowerCase()) && (b.lineCap = a)
  }, get lineJoin() {
    return b.lineJoin
  }, set lineJoin(a) {
    -1 !== ["round", "bevel", "miter"].indexOf(a.toLowerCase()) && (b.lineJoin = a)
  }, get miterLimit() {
    return b.miterLimit
  }, set miterLimit(a) {
    b.miterLimit = a
  }, get font() {
  }, set font(a) {
  }, get textAlign() {
  }, set textAlign(a) {
  }, get textBaseline() {
  }, set textBaseline(a) {
  }, get shadowOffsetX() {
  }, set shadowOffsetX(a) {
  }, get shadowOffsetY() {
  }, set shadowOffsetY(a) {
  }, get shadowBlur() {
  }, set shadowBlur(a) {
  }, get shadowColor() {
  }, set shadowColor(a) {
  }, clearRect:function() {
    throw"Pixel operation, makes no sense for PDF vectors.";
  }, fillRect:function(a, b, c, g) {
    q();
    e.rect(a, b, c, g, "F")
  }, strokeRect:function(a, b, c, g) {
    q();
    e.rect(a, b, c, g, "S")
  }, beginPath:function() {
    i = new r
  }, fill:function() {
  }, stroke:function() {
  }, clip:function() {
    throw"Not implemented yet";
  }, isPointInPath:function() {
    throw"Not implemented yet";
  }, closePath:function() {
    i.closePath()
  }, moveTo:function(a, b) {
    i.moveTo(a, b)
  }, lineTo:function(a, b) {
    i.lineTo(a, b)
  }, quadraticCurveTo:function() {
  }, bezierCurveTo:function(a, b, c, g, e, f) {
    i.bezierCurveTo(a, b, c, g, e, f)
  }, arcTo:function() {
  }, rect:function() {
  }, arc:function() {
  }, fillText:function() {
    throw"Not implemented yet";
  }, strokeText:function() {
    throw"Not implemented yet";
  }, measureText:function() {
    throw"Not implemented yet";
  }, drawImage:function() {
    throw"Not implemented yet";
  }, addHitRegion:function() {
    throw"Interactive features make no sense in a stitic PDF context";
  }, removeHitRegion:function() {
    throw"Interactive features make no sense in a stitic PDF context";
  }, createImageData:function() {
    throw"Pixel operations make no sense in a PDF vector context";
  }, getImageData:function() {
    throw"Pixel operations make no sense in a PDF vector context";
  }, putImageData:function() {
    throw"Pixel operations make no sense in a PDF vector context";
  }};
  var j = null, k = 0, l = 0, t, e, f = function() {
    if(1 == arguments.length) {
      "string" === typeof arguments[0] ? j = document.getElementById(arguments[0]) : "object" === typeof arguments[0] && (j = arguments[0]);
      if(!j) {
        throw"Unable to find target dom element from " + arguments[0];
      }
      k = j.offsetWidth;
      l = j.offsetHeight
    }else {
      2 == arguments.length && (k = parseInt(arguments[0]), l = parseInt(arguments[1]))
    }
    t = this;
    pdfWidth = k;
    pdfHeight = l;
    e = new jsPDF(l > k ? "portrait" : "landscape", "pt", [k, l])
  };
  f.prototype = {getContext:function(a) {
    if("2d" === a.toString().toLowerCase()) {
      return u = new s
    }
    throw"PDFCanvas only supports the 2D context";
  }, toDataURL:function(a) {
    if((a = a || void 0) && "application/pdf" !== a) {
      throw'Can only output generated PDF to data-url of type "application/pdf".';
    }
    return e.output("datauristring")
  }, toBlob:function() {
    throw"Not (yet) implemented.";
  }, get width() {
    return pdfWidth
  }, set width(a) {
    pdfWidth = parseInt(a)
  }, get height() {
    return pdfHeight
  }, set height(a) {
    pdfHeight = parseInt(a)
  }, test:function() {
    a: {
      console.log("Testing color style to color conversion ...");
      for(var a = [["#ff00ff", {r:1, g:0, b:1}], ["#f0f", {r:1, g:0, b:1}], ["#eeff00ff", {r:1, g:0, b:1, a:238 / 255}], ["rgb(255,255,0)", {r:1, g:1, b:0}], ["rgba(255,0,0,255)", {r:1, g:0, b:0, a:1}], ["rgba(255,0,0,0.5)", {r:1, g:0, b:0, a:0.5}], ["red", {r:1, g:0, b:0}]], b = 0, e = a.length;b < e;b++) {
        var g = c(a[b][0]), f;
        for(f in a[b][1]) {
          if(a[b][1][f] !== g[f]) {
            console.log("Failed!", a[b][0], a[b][1], g);
            break a
          }
        }
      }
      console.log("... all fine!")
    }
  }};
  return f
}();
