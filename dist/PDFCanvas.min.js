var PDFCanvas = function() {
  if(!("jsPDF" in window)) {
    throw"jsPDF is missing, make sure to include it before using PDFCanvas.";
  }
  var c = function(a) {
    var g = a.toLowerCase(), g = g.replace(/[\s]+/ig, ""), b = cR = cG = cB = void 0;
    if(-1 !== g.indexOf("#")) {
      a = g.replace("#", "0x"), 5 == a.length && (a = "0x" + a[2] + a[2] + a[3] + a[3] + a[4] + a[4]), a = parseInt(a, 16), 16777215 < a && (b = (a >> 24 & 255) / 255), cR = a >> 16 & 255, cG = a >> 8 & 255, cB = a & 255
    }else {
      if(-1 !== g.indexOf("rgb")) {
        g = g.replace(/rgb[a]?\(([^)]+)\)/ig, "$1"), cArr = g.split(","), cR = parseInt(cArr[0]), cG = parseInt(cArr[1]), cB = parseInt(cArr[2]), (b = cArr[3] ? parseFloat(cArr[3]) : void 0) && 1 < b && (b /= 255)
      }else {
        if(-1 !== g.indexOf("hsl")) {
          throw"HSL colors are not yet implemented";
        }
        if(n && g in n) {
          return n[g]
        }
        throw"Unable to parse color style: " + a;
      }
    }
    return{r:cR, g:cG, b:cB, a:b}
  }, q = function(a, b) {
    var c = parseInt(a.r) + "," + parseInt(a.g) + "," + parseInt(a.b);
    return 1 !== b ? "rgba(" + c + "," + b + ")" : "rgb(" + c + ")"
  }, n = {aqua:c("#00FFFF"), black:c("#000000"), blue:c("#0000FF"), fuchsia:c("#FF00FF"), gray:c("#808080"), green:c("#008000"), lime:c("#00FF00"), maroon:c("#800000"), navy:c("#000080"), olive:c("#808000"), purple:c("#800080"), red:c("#FF0000"), silver:c("#C0C0C0"), teal:c("#008080"), white:c("#FFFFFF"), yellow:c("#FFFF00")}, l = function() {
    e.setFillColor(b.fill.r, b.fill.g, b.fill.b);
    e.setDrawColor(b.stroke.r, b.stroke.g, b.stroke.b);
    e.setLineWidth(b.lineWidth)
  }, p = function() {
    this.reset()
  };
  p.prototype = {reset:function() {
    this.fill = this.stroke = {r:0, g:0, b:0};
    this.globalAlpha = 1;
    this.globalCompositeOperation = "source-over";
    this.lineCap = "butt";
    this.lineJoine = "miter";
    this.lineWidth = 1;
    this.miterLimit = null;
    this.shadowBlur = this.shadowOffsetX = this.shadowOffsetY = 0;
    this.fontFamily = this.shadowColor = null;
    this.fontSize = 10;
    this.fontStretch = this.fontVariant = this.fontStyle = this.fontWeight = null;
    this.textAlign = "start";
    this.textBaseline = "alphabetic"
  }};
  var f = function() {
    this.stack = [new p]
  };
  f.prototype = {push:function() {
    var a = new p;
    this.stack.push(a);
    return a
  }, pop:function() {
    if(0 == this.stack.length) {
      throw"Number of save() / restore() do not match!";
    }
    return this.stack.pop()
  }, top:function() {
    return this.stack[this.stack.length - 1]
  }};
  var r = function() {
    this.x = this.y = 0;
    this.vertices = [];
    this.location = [];
    this.closed = !1
  };
  r.prototype = {moveTo:function(a, b) {
    this.x = a;
    this.y = b;
    this.location = [a, b]
  }, lineTo:function(a, b) {
    this.vertices.push([a - this.location[0], b - this.location[1]]);
    this.location[0] = a;
    this.location[1] = b
  }, quadraticCurveTo:function(a, b, c, m) {
    var d = 2 / 3;
    this.vertices.push([this.location[0] + d * (a - this.location[0]) - this.location[0], this.location[1] + d * (b - this.location[1]) - this.location[1], c + d * (a - c) - this.location[0], m + d * (b - m) - this.location[1], c - this.location[0], m - this.location[1]]);
    this.location[0] = c;
    this.location[1] = m
  }, bezierCurveTo:function(a, b, c, d, e, f) {
    this.vertices.push([a - this.location[0], b - this.location[1], c - this.location[0], d - this.location[1], e - this.location[0], f - this.location[1]]);
    this.location[0] = e;
    this.location[1] = f
  }, closePath:function() {
    this.vertices.push(this.vertices[0].x - this.location[0], this.vertices[0].y - this.location[1]);
    this.closed = !0
  }};
  var u = void 0, h = new f, b = h.top(), d = null, s = function() {
  };
  s.prototype = {get canvas() {
    return t
  }, save:function() {
    h.push();
    b = h.top()
  }, restore:function() {
    h.pop();
    b = h.top()
  }, scale:function() {
    throw"Not implemented yet";
  }, rotate:function() {
    throw"Not implemented yet";
  }, translate:function() {
    throw"Not implemented yet";
  }, transform:function() {
    throw"Not implemented yet";
  }, setTransform:function() {
    throw"Not implemented yet";
  }, get globalAlpha() {
    return b.globalAlpha
  }, set globalAlpha(a) {
    b.globalAlpha = a
  }, get globalCompositeOperation() {
    return b.globalCompositeOperation
  }, set globalCompositeOperation(a) {
    b.globalCompositeOperation = a;
    throw"Not yet implemented.";
  }, get strokeStyle() {
    return q(b.stroke, b.globalAlpha)
  }, set strokeStyle(a) {
    a = c(a);
    b.stroke = a
  }, get fillStyle() {
    return q(b.fill, b.globalAlpha)
  }, set fillStyle(a) {
    a = c(a);
    b.fill = a
  }, createLinearGradient:function() {
    throw"Not yet implemented.";
  }, createRadialGradient:function() {
    throw"Not yet implemented.";
  }, createPattern:function() {
    throw"Not yet implemented.";
  }, get lineWidth() {
    return b.lineWidth
  }, set lineWidth(a) {
    b.lineWidth = a
  }, get lineCap() {
    return b.lineCap
  }, set lineCap(a) {
    -1 !== ["butt", "round", "square"].indexOf(a.toLowerCase()) && (b.lineCap = a)
  }, get lineJoin() {
    return b.lineJoin
  }, set lineJoin(a) {
    -1 !== ["round", "bevel", "miter"].indexOf(a.toLowerCase()) && (b.lineJoin = a)
  }, get miterLimit() {
    return b.miterLimit
  }, set miterLimit(a) {
    b.miterLimit = a
  }, get font() {
    return b.fontSize + "px " + b.fontFamily
  }, set font(a) {
    throw"Not implemented yet";
  }, get textAlign() {
    return b.textAlign
  }, set textAlign(a) {
    -1 !== ["start", "end", "left", "right", "center"].indexOf(a.toLowerCase()) && (b.textAlign = a)
  }, get textBaseline() {
    return b.textBaseline
  }, set textBaseline(a) {
    -1 !== "top hanging middle alphabetic ideographic bottom".split(" ").indexOf(a.toLowerCase()) && (b.textBaseline = a)
  }, get shadowOffsetX() {
    return b.shadowOffsetX
  }, set shadowOffsetX(a) {
    b.shadowOffsetX = a
  }, get shadowOffsetY() {
    return b.shadowOffsetY
  }, set shadowOffsetY(a) {
    b.shadowOffsetY = a
  }, get shadowBlur() {
    return b.shadowBlur
  }, set shadowBlur(a) {
    b.shadowBlur = a
  }, get shadowColor() {
    return b.shadowColor
  }, set shadowColor(a) {
    a = c(a);
    b.stroke = a;
    b.shadowColor = a
  }, clearRect:function() {
    throw"Pixel operation, makes no sense for PDF vectors.";
  }, fillRect:function(a, b, c, d) {
    l();
    e.rect(a, b, c, d, "F")
  }, strokeRect:function(a, b, c, d) {
    l();
    e.rect(a, b, c, d, "S")
  }, beginPath:function() {
    d = new r
  }, fill:function() {
    d && (l(), e.lines(d.vertices, d.x, d.y, [1, 1], "F"), d = null)
  }, stroke:function() {
    d && (l(), e.lines(d.vertices, d.x, d.y, [1, 1], "S"), d = null)
  }, clip:function() {
    throw"Not implemented yet";
  }, isPointInPath:function() {
    throw"Not implemented yet";
  }, closePath:function() {
    d.closePath()
  }, moveTo:function(a, b) {
    d.moveTo(a, b)
  }, lineTo:function(a, b) {
    d.lineTo(a, b)
  }, quadraticCurveTo:function(a, b, c, e) {
    d.quadraticCurveTo(a, b, c, e)
  }, bezierCurveTo:function(a, b, c, e, f, h) {
    d.bezierCurveTo(a, b, c, e, f, h)
  }, arcTo:function() {
    throw"Not implemented yet.";
  }, rect:function() {
  }, arc:function() {
  }, fillText:function() {
    throw"Not implemented yet";
  }, strokeText:function() {
    throw"Not implemented yet";
  }, measureText:function() {
    throw"Not implemented yet";
  }, drawImage:function() {
    throw"Not implemented yet";
  }, addHitRegion:function() {
    throw"Interactive features make no sense in a stitic PDF context";
  }, removeHitRegion:function() {
    throw"Interactive features make no sense in a stitic PDF context";
  }, createImageData:function() {
    throw"Pixel operations make no sense in a PDF vector context";
  }, getImageData:function() {
    throw"Pixel operations make no sense in a PDF vector context";
  }, putImageData:function() {
    throw"Pixel operations make no sense in a PDF vector context";
  }};
  var i = null, j = 0, k = 0, t, e, f = function() {
    if(1 == arguments.length) {
      "string" === typeof arguments[0] ? i = document.getElementById(arguments[0]) : "object" === typeof arguments[0] && (i = arguments[0]);
      if(!i) {
        throw"Unable to find target dom element from " + arguments[0];
      }
      j = i.offsetWidth;
      k = i.offsetHeight
    }else {
      2 == arguments.length && (j = parseInt(arguments[0]), k = parseInt(arguments[1]))
    }
    t = this;
    pdfWidth = j;
    pdfHeight = k;
    e = new jsPDF(k > j ? "portrait" : "landscape", "pt", [j, k])
  };
  f.prototype = {getContext:function(a) {
    if("2d" === a.toString().toLowerCase()) {
      return u = new s
    }
    throw"PDFCanvas only supports the 2D context";
  }, toDataURL:function(a) {
    if((a = a || void 0) && "application/pdf" !== a) {
      throw'Can only output generated PDF to data-url of type "application/pdf".';
    }
    return e.output("datauristring")
  }, toBlob:function() {
    throw"Not (yet) implemented.";
  }, get width() {
    return pdfWidth
  }, set width(a) {
    pdfWidth = parseInt(a)
  }, get height() {
    return pdfHeight
  }, set height(a) {
    pdfHeight = parseInt(a)
  }, test:function() {
    a: {
      console.log("Testing color style to color conversion ...");
      for(var a = [["#ff00ff", {r:255, g:0, b:255}], ["#f0f", {r:255, g:0, b:255}], ["#eeff00ff", {r:255, g:0, b:255, a:238 / 255}], ["rgb(255,255,0)", {r:255, g:255, b:0}], ["rgba(255,0,0,255)", {r:255, g:0, b:0, a:1}], ["rgba(255,0,0,0.5)", {r:255, g:0, b:0, a:0.5}], ["red", {r:255, g:0, b:0}]], b = 0, d = a.length;b < d;b++) {
        var e = c(a[b][0]), f;
        for(f in a[b][1]) {
          if(a[b][1][f] !== e[f]) {
            console.log("Failed!", a[b][0], a[b][1], e);
            break a
          }
        }
      }
      console.log("... all fine!")
    }
  }};
  return f
}();
